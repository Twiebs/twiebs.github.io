<!DOCTYPE html><html lang="en-us"><meta charset="UTF-8"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Torin Wiebelt's Blog</title><meta name="description" content="Torin wiebelts awesome blog and portfolio"><link rel="stylesheet" type="text/css" href="style.css"><body><nav class="navbar"><a href="index.html">Posts</a><a href="projects.html">Projects</a><a href="about.html">About</a><a href="archive.html">Archive</a></nav><h1>Current Posts</h1><div class="content"><h1>Generating Webpages With a Data Driven C API 

</h1><p>This site originialy used jekyll to generate a static site from markdown files; 
however, jekyll requires a large quantity of dependiecens and doesn't offer the flexibility I was looking for.
I decided to replace jekyll with a custom built tool for generating HTML within C++.  This allows any arbitrary
data source to be used in the HTML generation phase.  Requiring a plethora of external tools to generate html markup.  By providing a low level data driven
native interface for webpage generation, web content can be produced from any arbitrary data source in
a very flexible manner.  The native c interface induces more verbosity upfront but provides maximal
flexibility and customization power.

</p><h2>Features
</h2><ul><li>Data driven C interface
</li><li>procedures for buffers and format text
</li><li>Markdown parser
</li><li>Cpp Syntax highlighting
</li><li>Custom markdown function extention

</li></ul><p>All procedures in the library have many convenience variants around the much more low-level c procedures
When using the preprocessor macro SG_CPP additional feature such as function overloading and default values
are provided to make programming with the library more convieant while still exposing the more low-level
calls.  This system allows for maximal flexibility such as generating entire post archives with less than
a dozen lines of code.  Most of the procedures in the site-generator are provide both a format version and a pointer and length 
version for maximal flexibility 

</p><div style="background-color:rgba(34,34,34,1);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre>sg_fmt_h(1, <span style="color:#2ecc71;">"Heading %d: %s"</span>, 1, <span style="color:#2ecc71;">"Test"</span>);
sg_fmt_p(<span style="color:#2ecc71;">"paragraph with %s"</span>, <span style="color:#2ecc71;">"stuff"</span>);
sg_fmt_a(<span style="color:#2ecc71;">"%s.html"</span>, <span style="color:#2ecc71;">"my_page"</span>);

sg_fmt_set_next_class(<span style="color:#2ecc71;">"my-div-num-%d"</span>, 9);
sg_fmt_set_next_id(<span style="color:#2ecc71;">"id%d"</span>, 9);
sg_begin_div();
<span style="color:#34495e;">//...</span>
sg_end_div();
</pre></div><p>Both sg_fmt_set_next_class and sg_fmt_set_next_id apply to ALL other procedures in the utility.  This 
allows a simple way to proceduraly set the classname and id of html elements.

</p><h2>In Practice Examples

</h2><p>Here are some examples of the power and flexibility this tool provides for data-driven web development
This is the entire routine that generates the homepage of this blog

</p><div style="background-color:rgba(34,34,34,1);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre>sg::set_output_directory(<span style="color:#2ecc71;">"site"</span>);
sg::begin_document();
sg::add_stylesheet(<span style="color:#2ecc71;">"style.css"</span>);
sg::fmt_h(1, <span style="color:#2ecc71;">"Current Posts"</span>);
foreach_file_in_directory(<span style="color:#2ecc71;">"posts"</span>, [](<span style="color:#f1c40f;">FileInfo</span> file_info) {
    <span style="color:#f1c40f;">char</span> *file_data = read_file_into_memory(file_info.path);
    sg::begin_div(<span style="color:#2ecc71;">"content"</span>);
    sg::markdown(file_data);
    sg::end_div();
});
sg::end_document();

</pre></div><p>This routine generates a responsive photogallery by simply iterating over photos in a directory

</p><div style="background-color:rgba(34,34,34,1);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre>kate_wiebeltstuff

</pre></div></div><div class="content"><p>!title</p><p>Hotloading OpenGL Procedures with C preprocessor metaprograming</p><p>!date</p><p>2016-01-22</p><h1>Hotloading OpenGL procedures with C preprocessor metaprograming

</h1><p>One of the important features that I wanted when creating this new iteration of my game engine
Was the ablity to hotload code while the engine is still running.  I wanted this system to be as maximaly flexiable
as possible.  I really wanted to be able to hotload code that contained OpenGL functions.  This is how i accomplished
OpenGL function hotloading in the Venom game engine.

</p><h1>C Preprocessor Metaprograming

</h1><p>The problem is that when the dll containing the game code is realoaded after compilation functions that
exist in the engine's executable will not be avaible to it.  OpenGL functions are loaded in the engine
using the same system that the game code uses to obtain them.

</p><p>The opengl procedures are defined in the file opengl_procedures.h
This is a small example of what that file looks like

</p><div style="background-color:rgba(34,34,34,1);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre><span style="color:#34495e;">// opengl_procedures.h</span>
...

_(PFNGLGENTEXTURESPROC, glGenTextures)
_(PFNGLTEXSTORAGE2DPROC, glTexStorage2D)
_(PFNGLTEXSTORAGE3DPROC, glTexStorage3D)
_(PFNGLTEXIMAGE2DPROC, glTexImage2D)
_(PFNGLTEXIMAGE3DPROC, glTexImage3D)
_(PFNGLTEXSUBIMAGE2DPROC, glTexSubImage2D)
_(PFNGLTEXSUBIMAGE3DPROC, glTexSubImage3D)

...


</pre></div><p>Using the C preprocessor allows the defintions of the OpenGL functions to be pasted in locations where
they are realevant

</p><div style="background-color:rgba(34,34,34,1);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre><span style="color:#3498db;">struct</span> <span style="color:#f1c40f;">EngineAPI</span>
{
<span style="color:#e74c3c;">#define</span> _(sig, name) <span style="color:#f1c40f;">sig</span> name;
<span style="color:#e74c3c;">#include</span> <span style="color:#2ecc71;">"opengl_procedures.h"</span>
<span style="color:#e74c3c;">#undef</span> _
};


</pre></div><p>One very important facet of this system is that there is no differentation between how the
OpenGL procedures are called in debug and release builds.  This is acomplished by pasting the OpenGL
procedure list as global variables in the game module

</p><div style="background-color:rgba(34,34,34,1);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre><span style="color:#34495e;">//The Games Translation Unit</span>
<span style="color:#e74c3c;">#define</span> _(sig, name) <span style="color:#3498db;">static</span> <span style="color:#f1c40f;">sig</span> name;
<span style="color:#e74c3c;">#include</span> <span style="color:#2ecc71;">"opengl_procedures.h"</span>
<span style="color:#e74c3c;">#undef</span> _

<span style="color:#3498db;">extern</span> <span style="color:#2ecc71;">"C"</span>
<span style="color:#f1c40f;">void</span> on_module_load(<span style="color:#f1c40f;">EngineAPI</span> *api)
{
<span style="color:#e74c3c;">#define</span> _(sig,name) name = api-><span style="color:#e74c3c;">##name;</span>
<span style="color:#e74c3c;">#include</span> <span style="color:#2ecc71;">"opengl_procedures.h"</span>
<span style="color:#e74c3c;">#undef</span> _
}

</pre></div><p>With this small amount of code we are able to set the function pointers of our global OpenGL functions
within the game module to the procedures that have been loaded from the platform layers coresponding dynamic
OpenGL library.
</p></div><div class="content"><h1>Writing a new Game Engine
</h1><p>A year ago I started writing a 3D game engine.  Today I started writing a new 3D game engine from scratch using none of the code from the previous incardination.
This is because the original engine which I had dubbed "Raptor" was written to be very modular and generic.
The problem: too much effort was expended on organizing the code rather than solving the difficult technical problems involved with 3D game engine programming.
Another issue with the initial engine was that there was no defined goal of what exactly I wanted to achieve with the project.
At one point I had written a level editor without any intent to use it just though that it would be cool.
</p><h2>What was wrong
</h2><ul><li>C++ templates slowed down compile times
</li><li>Focused on too much on design and architecture rather than solving problems
</li><li>Written to be very generic rather than attack specific problems directly
</li></ul><p>The goals I have going into this project are more clearly defined then "just because".
Although the primary reasons for creating this engine are to state my curiosity about all aspects of game engine technologies I intend to work towards a tech demo with gameplay.
The plan is to create a small RPG style engine with a 3rd person combat system.
</p><h2>The Plan
</h2><ul><li>Procedurally Generated Terrain
</li><li>Collision Detection / Physics Engine
</li><li>OpenGL / Possibly Vulcan renderer
</li><ul><li>primary deferred rendering
</li><li>Cascaded shadow maps for large outdoor scenes
</li><li>SSAO
</li><li>secondary forward pass for transparency
</li><li>Procedural Animation system
</li></ul><li>3rd Person player controls with RPG elements
</li><li>Runtime hot loading of C++ dlls
</li><li>Asset hot reloading
</li><li>Audio mixer
</li></ul></div></body></html>