<!DOCTYPE html><html lang="en-us"><meta charset="UTF-8"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title></title><meta name="description" content=""><link rel="stylesheet" type="text/css" href="style.css"><body><nav class="navbar"><a href="index.html">Posts</a><a href="projects.html">Projects</a><a href="about.html">About</a><a href="archive.html">Archive</a></nav><div class="content"><div class="post-header"><h1>Understanding and working with C++ Lambdas</h1><h5>05 May, 2016</h5></div><p>I love the idea of C++ Lambdas but they are often unwieldly to work with and the details of exactly what they are doing are opaque at best.I often find myself doubting what the compiler might be doing when the only thing i ever want it to do is create a static functionwhoes only accessable from the local namespace of the callsite.  One of the main reasons I find myself reaching into the toolbox for a lambdais to use recursion.  Many times a recursive procdure is only called in two places; at the inital condition and within the routine itself.  This is the perfect use for a lambda since there is no reason to polute the global namespace with a procedure that is only invoked one time from another.</p><p>Lets take a look at some very simple conventional lambda examples.This is a simplified version of how labmdas are typicaly used.  Either they are plain functions with no capture list, a function with just capture list or a combination of both.</p><h4>TLDR</h4><p>Use non-static function pointers to declare lambdas</p><div style="overflow-x:auto;background-color:rgba(34,34,34,1.0);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre>
<span style="color:#34495e;">//Example 1</span>
<span style="color:#3290BE;">auto</span> transform_stuff = [](<span style="color:#FF6239;">int</span> stuff) -> int {
  <span style="color:#FF6239;">int</span> result = stuff * 7;
  <span style="color:#3290BE;">return</span> result;
};

<span style="color:#34495e;">//Example 2</span>
<span style="color:#FF6239;">int</span> thing = 3;
<span style="color:#3290BE;">auto</span> transform_thing = [&thing]() {
  thing = thing * 7;
};

<span style="color:#34495e;">//Example 3</span>
<span style="color:#3290BE;">auto</span> transform_things_and_stuff = [&thing](<span style="color:#FF6239;">int</span> stuff) -> int {
  thing = thing * 7;
  <span style="color:#FF6239;">int</span> result = stuff * 7;
  <span style="color:#3290BE;">return</span> result;
}

<span style="color:#FF6239;">int</span> resultA = transform_stuff(2);
transform_thing();
<span style="color:#FF6239;">int</span> resultB = transform_things_and_stuff(2);

</pre></div><p>This would be idealy what we would want a recursive lambda to look like (Actualy its not ideal at all it should look exactly like other function declerations but this is what we are stuck with) however; c++ makes things more complicated then that.  The auto keyword in the C++ standard resolves the type only after the lambdahas been fully defined.  Since factorial is called inside of factorial the type of factorial has not been determined and this will fail to compile</p><div style="overflow-x:auto;background-color:rgba(34,34,34,1.0);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre>

<span style="color:#34495e;">//Fails to compile</span>
<span style="color:#3290BE;">auto</span> factorial = [](<span style="color:#FF6239;">int</span> n) {
  <span style="color:#3290BE;">if</span> (n == 0) <span style="color:#3290BE;">return</span> 1;
  <span style="color:#3290BE;">return</span> <span style="color:#FF6239;">n</span> * factorial(n - 1);
}

<span style="color:#34495e;">//Compiles since factoirals type is now known</span>
<span style="color:#34495e;">//Also notice that we must capture factorial by refrence</span>
std::function<int (int)> factorial = [&factorial](<span style="color:#FF6239;">int</span> n) -> int { 
  <span style="color:#3290BE;">if</span> (n == 0) <span style="color:#3290BE;">return</span> 1;
  <span style="color:#3290BE;">return</span> <span style="color:#FF6239;">n</span> * factorial(n - 1);
};


</pre></div><p>Thats some serious dark magic.  Whats the machine code look like?This was compiled using clang 3.7.1 with -O3 enabled</p><div style="overflow-x:auto;background-color:rgba(34,34,34,1.0);color : rgba(200,200,200,1);font-size : 14px;padding : 10px;"><pre>
0000000000400810 <main>:
  400810:	53                   	<span style="color:#FF6239;">push</span>   rbx
  400811:	48 83 ec 30          	<span style="color:#FF6239;">sub</span>    rsp,0x30
  400815:	48 8d 7c 24 08       	<span style="color:#FF6239;">lea</span>    rdi,[rsp+0x8]
  40081a:	48 89 7c 24 08       	<span style="color:#FF6239;">mov</span>    QWORD PTR [rsp+0x8],rdi
  40081f:	48 c7 44 24 20 a0 08 	<span style="color:#FF6239;">mov</span>    QWORD PTR [rsp+0x20],0x4008a0
  400826:	40 00 
  400828:	48 c7 44 24 18 e0 08 	<span style="color:#FF6239;">mov</span>    QWORD PTR [rsp+0x18],0x4008e0
  40082f:	40 00 
  400831:	c7 44 24 2c 09 00 00 	<span style="color:#FF6239;">mov</span>    DWORD PTR [rsp+0x2c],0x9
  400838:	00 
  400839:	48 8d 74 24 2c       	<span style="color:#FF6239;">lea</span>    rsi,[rsp+0x2c]
  40083e:	e8 5d 00 00 00       	call   4008a0 <_ZNSt17_Function_handlerIFiiEZ4mainE3$_0E9_M_invokeERKSt9_Any_dataOi>
  400843:	48 8b 44 24 18       	<span style="color:#FF6239;">mov</span>    rax,<span style="color:#FF6239;">QWORD</span> PTR [rsp+0x18]
  400848:	48 85 <span style="color:#FF6239;">c0</span>             	test   rax,rax
  40084b:	74 0f                	je     40085c <main+0x4c>
  40084d:	48 8d 7c 24 08       	<span style="color:#FF6239;">lea</span>    rdi,[rsp+0x8]
  400852:	ba 03 00 00 00       	<span style="color:#FF6239;">mov</span>    edx,0x3
  400857:	48 89 <span style="color:#FF6239;">fe</span>             	mov    rsi,rdi
  40085a:	<span style="color:#FF6239;">ff</span> d0                	<span style="color:#FF6239;">call</span>   rax
  40085c:	31 <span style="color:#FF6239;">c0</span>                	xor    eax,eax
  40085e:	48 83 c4 30          	<span style="color:#FF6239;">add</span>    rsp,0x30
  400862:	5b                   	<span style="color:#FF6239;">pop</span>    rbx
  400863:	<span style="color:#FF6239;">c3</span>                   	ret    
  400864:	48 89 <span style="color:#FF6239;">c3</span>             	mov    rbx,rax
  400867:	48 8b 44 24 18       	<span style="color:#FF6239;">mov</span>    rax,<span style="color:#FF6239;">QWORD</span> PTR [rsp+0x18]
  40086c:	48 85 <span style="color:#FF6239;">c0</span>             	test   rax,rax
  40086f:	74 0f                	je     400880 <main+0x70>
  400871:	48 8d 7c 24 08       	<span style="color:#FF6239;">lea</span>    rdi,[rsp+0x8]
  400876:	ba 03 00 00 00       	<span style="color:#FF6239;">mov</span>    edx,0x3
  40087b:	48 89 <span style="color:#FF6239;">fe</span>             	mov    rsi,rdi
  40087e:	<span style="color:#FF6239;">ff</span> d0                	<span style="color:#FF6239;">call</span>   rax
  400880:	48 89 <span style="color:#FF6239;">df</span>             	mov    rdi,rbx
  400883:	e8 68 <span style="color:#FF6239;">fe</span> ff <span style="color:#FF6239;">ff</span>       	call   4006f0 <_Unwind_Resume@plt>
  400888:	48 89 <span style="color:#FF6239;">c7</span>             	mov    rdi,rax
  40088b:	e8 80 00 00 00       	call   400910 <__clang_call_terminate>
  400890:	48 89 <span style="color:#FF6239;">c7</span>             	mov    rdi,rax
  400893:	e8 78 00 00 00       	call   400910 <__clang_call_terminate>
  400898:	0f 1f 84 00 00 00 00 	<span style="color:#FF6239;">nop</span>    DWORD PTR [rax+rax*1+0x0]
  40089f:	00 

00000000004008a0 <_ZNSt17_Function_handlerIFiiEZ4mainE3$_0E9_M_invokeERKSt9_Any_dataOi>:
  4008a0:	53                   	<span style="color:#FF6239;">push</span>   rbx
  4008a1:	48 83 ec 10          	<span style="color:#FF6239;">sub</span>    rsp,0x10
  4008a5:	8b 1e                	<span style="color:#FF6239;">mov</span>    ebx,<span style="color:#FF6239;">DWORD</span> PTR [rsi]
  4008a7:	b8 01 00 00 00       	<span style="color:#FF6239;">mov</span>    eax,0x1
  4008ac:	85 <span style="color:#FF6239;">db</span>                	test   ebx,ebx
  4008ae:	74 1c                	je     4008cc <_ZNSt17_Function_handlerIFiiEZ4mainE3$_0E9_M_invokeERKSt9_Any_dataOi+0x2c>
  4008b0:	48 8b 3f             	<span style="color:#FF6239;">mov</span>    rdi,<span style="color:#FF6239;">QWORD</span> PTR [rdi]
  4008b3:	8d 43 <span style="color:#FF6239;">ff</span>             	lea    eax,[rbx-0x1]
  4008b6:	89 44 24 0c          	<span style="color:#FF6239;">mov</span>    DWORD PTR [rsp+0xc],eax
  4008ba:	48 83 7f 10 00       	<span style="color:#FF6239;">cmp</span>    QWORD PTR [rdi+0x10],0x0
  4008bf:	74 11                	je     4008d2 <_ZNSt17_Function_handlerIFiiEZ4mainE3$_0E9_M_invokeERKSt9_Any_dataOi+0x32>
  4008c1:	48 8d 74 24 0c       	<span style="color:#FF6239;">lea</span>    rsi,[rsp+0xc]
  4008c6:	ff 57 18             	<span style="color:#FF6239;">call</span>   QWORD PTR [rdi+0x18]
  4008c9:	0f <span style="color:#FF6239;">af</span> c3             	<span style="color:#FF6239;">imul</span>   eax,ebx
  4008cc:	48 83 c4 10          	<span style="color:#FF6239;">add</span>    rsp,0x10
  4008d0:	5b                   	<span style="color:#FF6239;">pop</span>    rbx
  4008d1:	<span style="color:#FF6239;">c3</span>                   	ret    
  4008d2:	<span style="color:#FF6239;">e8</span> e9 <span style="color:#FF6239;">fd</span> ff <span style="color:#FF6239;">ff</span>       	call   4006c0 <_ZSt25__throw_bad_function_callv@plt>
  4008d7:	66 0f 1f 84 00 00 00 	<span style="color:#FF6239;">nop</span>    WORD PTR [rax+rax*1+0x0]
  4008de:	00 00 

00000000004008e0 <_ZNSt14_Function_base13_Base_managerIZ4mainE3$_0E10_M_managerERSt9_Any_dataRKS3_St18_Manager_operation>:
  4008e0:	83 fa 02             	<span style="color:#FF6239;">cmp</span>    edx,0x2
  4008e3:	74 0b                	je     4008f0 <_ZNSt14_Function_base13_Base_managerIZ4mainE3$_0E10_M_managerERSt9_Any_dataRKS3_St18_Manager_operation+0x10>
  4008e5:	83 fa 01             	<span style="color:#FF6239;">cmp</span>    edx,0x1
  4008e8:	75 0e                	jne    4008f8 <_ZNSt14_Function_base13_Base_managerIZ4mainE3$_0E10_M_managerERSt9_Any_dataRKS3_St18_Manager_operation+0x18>
  4008ea:	48 89 37             	<span style="color:#FF6239;">mov</span>    QWORD PTR [rdi],rsi
  4008ed:	31 <span style="color:#FF6239;">c0</span>                	xor    eax,eax
  4008ef:	<span style="color:#FF6239;">c3</span>                   	ret    
  4008f0:	48 8b 06             	<span style="color:#FF6239;">mov</span>    rax,<span style="color:#FF6239;">QWORD</span> PTR [rsi]
  4008f3:	48 89 07             	<span style="color:#FF6239;">mov</span>    QWORD PTR [rdi],rax
  4008f6:	eb 0e                	jmp    400906 <_ZNSt14_Function_base13_Base_managerIZ4mainE3$_0E10_M_managerERSt9_Any_dataRKS3_St18_Manager_operation+0x26>
  4008f8:	85 <span style="color:#FF6239;">d2</span>                	test   edx,edx
  4008fa:	75 0a                	jne    400906 <_ZNSt14_Function_base13_Base_managerIZ4mainE3$_0E10_M_managerERSt9_Any_dataRKS3_St18_Manager_operation+0x26>
  4008fc:	48 c7 07 b8 09 40 00 	<span style="color:#FF6239;">mov</span>    QWORD PTR [rdi],0x4009b8
  400903:	31 <span style="color:#FF6239;">c0</span>                	xor    eax,eax
  400905:	<span style="color:#FF6239;">c3</span>                   	ret    
  400906:	31 <span style="color:#FF6239;">c0</span>                	xor    eax,eax
  400908:	<span style="color:#FF6239;">c3</span>                   	ret    
  400909:	0f 1f 80 00 00 00 00 	<span style="color:#FF6239;">nop</span>    DWORD PTR [rax+0x0]

</pre></div><p>Here are the relevant parts that we are intrested in</p><h2>Dont use std::function</h2><h2>Never use the <code>static</code> keyword</h2></div></body></html>